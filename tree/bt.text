DÆ°á»›i Ä‘Ã¢y lÃ  danh sÃ¡ch má»™t vÃ i bÃ i toÃ¡n vá» cÃ¢y trÃªn **LeetCode** cÃ¹ng hÆ°á»›ng dáº«n xá»­ lÃ½:

---

### **1. Binary Tree Inorder Traversal (Medium)**
- **Link**: [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)
- **MÃ´ táº£**:
  Duyá»‡t cÃ¢y nhá»‹ phÃ¢n theo thá»© tá»± **Inorder** (trÃ¡i -> gá»‘c -> pháº£i).
- **HÆ°á»›ng dáº«n**:
  Sá»­ dá»¥ng Ä‘á»‡ quy hoáº·c vÃ²ng láº·p vá»›i stack Ä‘á»ƒ duyá»‡t cÃ¢y.
- **Code máº«u**:
  ```cpp
  void inorder(TreeNode* root, vector<int>& result) {
      if (!root) return;
      inorder(root->left, result);
      result.push_back(root->val);
      inorder(root->right, result);
  }

  vector<int> inorderTraversal(TreeNode* root) {
      vector<int> result;
      inorder(root, result);
      return result;
  }
  ```

---

### **2. Maximum Depth of Binary Tree (Easy)**
- **Link**: [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
- **MÃ´ táº£**:
  TÃ¬m Ä‘á»™ sÃ¢u lá»›n nháº¥t cá»§a cÃ¢y nhá»‹ phÃ¢n.
- **HÆ°á»›ng dáº«n**:
  Sá»­ dá»¥ng Ä‘á»‡ quy tÃ­nh Ä‘á»™ sÃ¢u.
- **Code máº«u**:
  ```cpp
  int maxDepth(TreeNode* root) {
      if (!root) return 0;
      return 1 + max(maxDepth(root->left), maxDepth(root->right));
  }
  ```

---

### **3. Lowest Common Ancestor of a Binary Tree (Medium)**
- **Link**: [Lowest Common Ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)
- **MÃ´ táº£**:
  TÃ¬m **LCA** (nÃºt cha chung gáº§n nháº¥t) cá»§a hai nÃºt trong cÃ¢y nhá»‹ phÃ¢n.
- **HÆ°á»›ng dáº«n**:
  Sá»­ dá»¥ng Ä‘á»‡ quy kiá»ƒm tra nÃºt hiá»‡n táº¡i cÃ³ chá»©a cáº£ hai nÃºt khÃ´ng.
- **Code máº«u**:
  ```cpp
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
      if (!root || root == p || root == q) return root;
      TreeNode* left = lowestCommonAncestor(root->left, p, q);
      TreeNode* right = lowestCommonAncestor(root->right, p, q);
      return left && right ? root : left ? left : right;
  }
  ```

---

### **4. Diameter of Binary Tree (Easy)**
- **Link**: [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)
- **MÃ´ táº£**:
  TÃ­nh Ä‘Æ°á»ng kÃ­nh cá»§a cÃ¢y nhá»‹ phÃ¢n (Ä‘Æ°á»ng Ä‘i dÃ i nháº¥t giá»¯a hai nÃºt báº¥t ká»³).
- **HÆ°á»›ng dáº«n**:
  Sá»­ dá»¥ng DFS vÃ  cáº­p nháº­t Ä‘Æ°á»ng kÃ­nh táº¡i má»—i nÃºt.
- **Code máº«u**:
  ```cpp
  int diameter = 0;
  int dfs(TreeNode* root) {
      if (!root) return 0;
      int left = dfs(root->left);
      int right = dfs(root->right);
      diameter = max(diameter, left + right);
      return max(left, right) + 1;
  }

  int diameterOfBinaryTree(TreeNode* root) {
      dfs(root);
      return diameter;
  }
  ```

---

### **5. Path Sum (Easy)**
- **Link**: [Path Sum](https://leetcode.com/problems/path-sum/)
- **MÃ´ táº£**:
  Kiá»ƒm tra xem cÃ³ Ä‘Æ°á»ng Ä‘i tá»« gá»‘c Ä‘áº¿n lÃ¡ nÃ o cÃ³ tá»•ng báº±ng giÃ¡ trá»‹ má»¥c tiÃªu khÃ´ng.
- **HÆ°á»›ng dáº«n**:
  Trá»« giÃ¡ trá»‹ nÃºt khá»i má»¥c tiÃªu khi duyá»‡t qua cÃ¡c nÃºt, kiá»ƒm tra táº¡i lÃ¡.
- **Code máº«u**:
  ```cpp
  bool hasPathSum(TreeNode* root, int targetSum) {
      if (!root) return false;
      targetSum -= root->val;
      if (!root->left && !root->right) return targetSum == 0;
      return hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum);
  }
  ```

---

### **6. Symmetric Tree (Easy)**
- **Link**: [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)
- **MÃ´ táº£**:
  Kiá»ƒm tra xem cÃ¢y nhá»‹ phÃ¢n cÃ³ Ä‘á»‘i xá»©ng khÃ´ng.
- **HÆ°á»›ng dáº«n**:
  So sÃ¡nh hai nhÃ¡nh trÃ¡i vÃ  pháº£i cá»§a cÃ¢y.
- **Code máº«u**:
  ```cpp
  bool isMirror(TreeNode* t1, TreeNode* t2) {
      if (!t1 && !t2) return true;
      if (!t1 || !t2 || t1->val != t2->val) return false;
      return isMirror(t1->left, t2->right) && isMirror(t1->right, t2->left);
  }

  bool isSymmetric(TreeNode* root) {
      return !root || isMirror(root->left, root->right);
  }
  ```

---

### **7. Construct Binary Tree from Inorder and Postorder Traversal (Medium)**
- **Link**: [Construct Binary Tree](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
- **MÃ´ táº£**:
  XÃ¢y dá»±ng cÃ¢y nhá»‹ phÃ¢n tá»« hai máº£ng **Inorder** vÃ  **Postorder**.
- **HÆ°á»›ng dáº«n**:
  Duyá»‡t ngÆ°á»£c tá»« **Postorder** Ä‘á»ƒ tÃ¬m nÃºt gá»‘c, phÃ¢n máº£ng **Inorder** Ä‘á»ƒ tÃ¬m nhÃ¡nh con trÃ¡i vÃ  pháº£i.
- **Code máº«u**:
  ```cpp
  TreeNode* build(vector<int>& inorder, vector<int>& postorder, int inStart, int inEnd, int& postIndex) {
      if (inStart > inEnd) return nullptr;
      TreeNode* root = new TreeNode(postorder[postIndex--]);
      int inIndex = find(inorder.begin(), inorder.end(), root->val) - inorder.begin();
      root->right = build(inorder, postorder, inIndex + 1, inEnd, postIndex);
      root->left = build(inorder, postorder, inStart, inIndex - 1, postIndex);
      return root;
  }

  TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
      int postIndex = postorder.size() - 1;
      return build(inorder, postorder, 0, inorder.size() - 1, postIndex);
  }
  ```

---

### **Lá»i khuyÃªn**
- **Báº¯t Ä‘áº§u tá»« cÃ¡c bÃ i dá»…** Ä‘á»ƒ quen vá»›i cáº¥u trÃºc cÃ¢y vÃ  cÃ¡c thuáº­t toÃ¡n nhÆ° DFS, BFS.
- **Duyá»‡t cÃ¢y (traversal)** lÃ  ká»¹ nÄƒng cÆ¡ báº£n, vÃ¬ váº­y hÃ£y thÃ nh tháº¡o Inorder, Preorder, Postorder.
- Dáº§n dáº§n, chuyá»ƒn sang cÃ¡c bÃ i phá»©c táº¡p nhÆ° tÃ¬m LCA, Ä‘Æ°á»ng kÃ­nh, hoáº·c xÃ¢y dá»±ng cÃ¢y.

Náº¿u báº¡n muá»‘n giáº£i bÃ i nÃ o cá»¥ thá»ƒ hÆ¡n, mÃ¬nh cÃ³ thá»ƒ há»— trá»£ phÃ¢n tÃ­ch chi tiáº¿t! ğŸ˜Š