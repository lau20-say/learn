Bit manipulation l√† m·ªôt ph·∫ßn quan tr·ªçng trong l·∫≠p tr√¨nh, ƒë·∫∑c bi·ªát trong C++ khi l√†m vi·ªác v·ªõi hi·ªáu su·∫•t cao ho·∫∑c x·ª≠ l√Ω d·ªØ li·ªáu nh·ªã ph√¢n. ƒê√¢y l√† c√°ch b·∫°n c√≥ th·ªÉ thao t√°c tr·ª±c ti·∫øp tr√™n c√°c bit c·ªßa m·ªôt s·ªë nguy√™n, gi√∫p tƒÉng hi·ªáu qu·∫£ v√† gi·∫£m chi ph√≠ t√≠nh to√°n so v·ªõi c√°c ph√©p to√°n truy·ªÅn th·ªëng.

---

## **1. Bi·ªÉu di·ªÖn bit trong C++**
C√°c s·ªë nguy√™n trong C++ ƒë∆∞·ª£c l∆∞u tr·ªØ d∆∞·ªõi d·∫°ng nh·ªã ph√¢n (binary), t·ª©c l√† chu·ªói c√°c bit 0 v√† 1.

V√≠ d·ª•:
- S·ªë th·∫≠p ph√¢n `5` c√≥ bi·ªÉu di·ªÖn nh·ªã ph√¢n: `101`
- S·ªë th·∫≠p ph√¢n `10` c√≥ bi·ªÉu di·ªÖn nh·ªã ph√¢n: `1010`

K√≠ch th∆∞·ªõc c·ªßa c√°c ki·ªÉu s·ªë nguy√™n (integer) quy·∫øt ƒë·ªãnh s·ªë bit m√† ch√∫ng s·ª≠ d·ª•ng:
- `int`: Th∆∞·ªùng l√† 32 bit.
- `short`: 16 bit.
- `long`: √çt nh·∫•t 32 bit.
- `long long`: √çt nh·∫•t 64 bit.

---

## **2. C√°c ph√©p to√°n bit c∆° b·∫£n**

| To√°n t·ª≠       | √ù nghƒ©a                                                                                       |
|---------------|-----------------------------------------------------------------------------------------------|
| `&` (AND)     | K·∫øt qu·∫£ l√† `1` n·∫øu c·∫£ hai bit ƒë·ªÅu l√† `1`, ng∆∞·ª£c l·∫°i l√† `0`.                                   |
| `|` (OR)      | K·∫øt qu·∫£ l√† `1` n·∫øu √≠t nh·∫•t m·ªôt trong hai bit l√† `1`.                                          |
| `^` (XOR)     | K·∫øt qu·∫£ l√† `1` n·∫øu hai bit kh√°c nhau, ng∆∞·ª£c l·∫°i l√† `0`.                                       |
| `~` (NOT)     | ƒê·∫£o ng∆∞·ª£c t·∫•t c·∫£ c√°c bit (`0` th√†nh `1` v√† `1` th√†nh `0`).                                   |
| `<<` (Left Shift)  | D·ªãch c√°c bit sang tr√°i, th√™m `0` v√†o c√°c bit b√™n ph·∫£i.                                    |
| `>>` (Right Shift) | D·ªãch c√°c bit sang ph·∫£i, v·ªõi s·ªë d∆∞∆°ng th√¨ th√™m `0` c√≤n s·ªë √¢m th√¨ th√™m `1` (d·ª±a tr√™n ki·ªÉu d·∫•u). |

---

### **2.1. V√≠ d·ª• c√°c ph√©p to√°n**

#### AND (`&`):
```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 5;   // 101
    int b = 3;   // 011
    cout << (a & b) << endl; // K·∫øt qu·∫£: 1 (001)
    return 0;
}
```

#### OR (`|`):
```cpp
int a = 5;   // 101
int b = 3;   // 011
cout << (a | b) << endl; // K·∫øt qu·∫£: 7 (111)
```

#### XOR (`^`):
```cpp
int a = 5;   // 101
int b = 3;   // 011
cout << (a ^ b) << endl; // K·∫øt qu·∫£: 6 (110)
```

#### NOT (`~`):
```cpp
int a = 5;   // 101
cout << (~a) << endl;    // K·∫øt qu·∫£: -6 (ph·ªß ƒë·ªãnh t·∫•t c·∫£ c√°c bit, t√≠nh c·∫£ bit d·∫•u)
```

#### Left Shift (`<<`):
```cpp
int a = 5;   // 101
cout << (a << 1) << endl;  // K·∫øt qu·∫£: 10 (1010 - d·ªãch tr√°i m·ªôt v·ªã tr√≠)
```

#### Right Shift (`>>`):
```cpp
int a = 5;   // 101
cout << (a >> 1) << endl;  // K·∫øt qu·∫£: 2 (10 - d·ªãch ph·∫£i m·ªôt v·ªã tr√≠)
```

---

## **3. C√°c k·ªπ thu·∫≠t th∆∞·ªùng d√πng v·ªõi bit manipulation**

### **3.1. Ki·ªÉm tra bit th·ª© `i`**
B·∫°n c√≥ th·ªÉ ki·ªÉm tra xem bit th·ª© `i` c·ªßa m·ªôt s·ªë c√≥ ph·∫£i l√† `1` hay kh√¥ng b·∫±ng c√°ch s·ª≠ d·ª•ng AND (`&`) v·ªõi `1 << i`.

```cpp
bool isBitSet(int n, int i) {
    return (n & (1 << i)) != 0;
}

// V√≠ d·ª•:
int n = 5; // 101
cout << isBitSet(n, 0) << endl; // K·∫øt qu·∫£: true (bit 0 l√† 1)
cout << isBitSet(n, 1) << endl; // K·∫øt qu·∫£: false (bit 1 l√† 0)
```

---

### **3.2. ƒê·∫∑t bit th·ª© `i` th√†nh 1**
S·ª≠ d·ª•ng OR (`|`) v·ªõi `1 << i`.

```cpp
int setBit(int n, int i) {
    return n | (1 << i);
}

// V√≠ d·ª•:
int n = 5; // 101
cout << setBit(n, 1) << endl; // K·∫øt qu·∫£: 7 (111)
```

---

### **3.3. X√≥a bit th·ª© `i` (ƒë·∫∑t bit th·ª© `i` th√†nh 0)**
S·ª≠ d·ª•ng AND (`&`) v·ªõi ph·ªß ƒë·ªãnh c·ªßa `1 << i`.

```cpp
int clearBit(int n, int i) {
    return n & (~(1 << i));
}

// V√≠ d·ª•:
int n = 5; // 101
cout << clearBit(n, 2) << endl; // K·∫øt qu·∫£: 1 (001)
```

---

### **3.4. ƒê·∫£o bit th·ª© `i`**
S·ª≠ d·ª•ng XOR (`^`) v·ªõi `1 << i`.

```cpp
int toggleBit(int n, int i) {
    return n ^ (1 << i);
}

// V√≠ d·ª•:
int n = 5; // 101
cout << toggleBit(n, 0) << endl; // K·∫øt qu·∫£: 4 (100)
cout << toggleBit(n, 1) << endl; // K·∫øt qu·∫£: 7 (111)
```

---

### **3.5. ƒê·∫øm s·ªë bit 1 trong m·ªôt s·ªë**
S·ª≠ d·ª•ng v√≤ng l·∫∑p v·ªõi AND (`&`).

```cpp
int countSetBits(int n) {
    int count = 0;
    while (n) {
        count += n & 1; // N·∫øu bit cu·ªëi l√† 1
        n >>= 1;        // D·ªãch ph·∫£i ƒë·ªÉ ki·ªÉm tra bit ti·∫øp theo
    }
    return count;
}

// V√≠ d·ª•:
int n = 5; // 101
cout << countSetBits(n) << endl; // K·∫øt qu·∫£: 2
```

---

### **3.6. Ki·ªÉm tra s·ªë m≈© c·ªßa 2**
M·ªôt s·ªë l√† l≈©y th·ª´a c·ªßa 2 n·∫øu v√† ch·ªâ n·∫øu n√≥ ch·ªâ c√≥ ƒë√∫ng 1 bit 1.

```cpp
bool isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}

// V√≠ d·ª•:
cout << isPowerOfTwo(4) << endl; // true (4 = 100)
cout << isPowerOfTwo(5) << endl; // false (5 = 101)
```

---

### **3.7. T√¨m s·ªë duy nh·∫•t trong m·∫£ng**
N·∫øu m·ªói s·ªë trong m·∫£ng xu·∫•t hi·ªán 2 l·∫ßn tr·ª´ 1 s·ªë xu·∫•t hi·ªán 1 l·∫ßn, b·∫°n c√≥ th·ªÉ d√πng XOR ƒë·ªÉ t√¨m s·ªë ƒë√≥:

```cpp
int findUnique(vector<int>& nums) {
    int unique = 0;
    for (int num : nums) {
        unique ^= num; // XOR m·ªçi ph·∫ßn t·ª≠
    }
    return unique;
}

// V√≠ d·ª•:
vector<int> nums = {2, 3, 2, 4, 4};
cout << findUnique(nums) << endl; // K·∫øt qu·∫£: 3
```

---

## **4. C√°c b√†i t·∫≠p th·ª±c h√†nh**
1. Ki·ªÉm tra xem m·ªôt s·ªë l√† s·ªë ch·∫µn hay l·∫ª ch·ªâ d√πng bit.
2. ƒê·∫£o ng∆∞·ª£c c√°c bit trong m·ªôt s·ªë 32-bit.
3. T√¨m s·ªë l·ªõn nh·∫•t nh·ªè h∆°n m·ªôt s·ªë `n` c√≥ c√πng s·ªë bit 1.
4. X√¢y d·ª±ng m·ªôt s·ªë t·ª´ c√°c bit l·∫ª c·ªßa m·ªôt s·ªë nguy√™n.

---

Bit manipulation trong C++ c·ª±c k·ª≥ m·∫°nh m·∫Ω v√† ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i trong t·ªëi ∆∞u h√≥a, thu·∫≠t to√°n ƒë·ªì h·ªça, v√† h·ªá th·ªëng nh√∫ng. N·∫øu b·∫°n luy·ªán t·∫≠p th∆∞·ªùng xuy√™n, n√≥ s·∫Ω tr·ªü th√†nh m·ªôt c√¥ng c·ª• r·∫•t h·ªØu √≠ch trong b·ªô k·ªπ nƒÉng l·∫≠p tr√¨nh c·ªßa b·∫°n! üöÄ